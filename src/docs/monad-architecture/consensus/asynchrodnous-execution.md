# 异步执行

### 摘要

异步执行是一项核心技术，通过将共识机制与交易执行解耦，使 Monad 能够显著提升系统处理吞吐量。

这种解耦架构使得 Monad 可以大幅扩展执行预算——原本执行阶段仅占用区块时间的很小部分，现在能够充分利用完整的区块时间窗口。

### 背景说明：交错执行模式的效率瓶颈
共识机制是指节点间就交易排序达成一致的过程，而交易执行则是实际运行这些交易并更新状态的过程。

在以太坊及大多数其他区块链中，交易执行是达成共识的前提条件。当节点对某个区块达成共识时，它们同时确认了以下两点：(1) 区块中包含的交易列表；(2) 执行这些交易后表征完整状态变化的默克尔根。因此，领导者必须在发布提案前完成区块内所有交易的执行，而验证节点也必须在投票响应前执行完这些交易。

我们将这种模式的区块链称为**执行与共识交错型**架构。在此范式下，执行过程的时间预算被极度压缩，因为交易需要被执行两次（提案方和验证方），同时还要为多轮全球节点间的共识通信留出足够时间。

更关键的是，由于执行过程会阻塞共识进度，区块的gas上限必须设定得极为保守，以确保在最坏情况下所有节点都能在时限内完成计算。

这就导致单个区块的gas上限所能覆盖的计算量，仅占区块时间资源的极小部分。以以太坊为例：其gas上限（最坏情况3000万gas）对应的计算耗时约100毫秒，而实际区块间隔却长达12秒。

![time budget for execution](/images/docs/asynchronous_execution_budget.png)
*以太坊执行预算与出块时间的对比分析*

也就是说，实际执行时间仅占出块间隔的1%！简而言之，共识与执行的交错模式导致了时间利用率被极度压缩。 但如果我们可以突破这种限制呢？


### 异步执行
Monad 通过将执行环节从共识关键路径中剥离，实现了共识与执行的解耦，使执行过程转入一个略有延迟的独立通道。

**在 Monad 中，节点达成共识（即对交易排序达成一致）时，并不需要实际执行这些交易。**

这意味着：
- 领导者无需知晓最终状态根即可提出交易排序方案
- 验证节点无需确认区块内所有交易是否执行成功（例如是否发生回滚）即可对区块有效性进行投票

当区块完成最终确认后，网络中的所有节点（验证节点和全节点）才会执行该区块的交易以生成最新且达成一致的状态。

这一变革使得执行过程可以获得完整的区块时间预算。通过以下对比示意图可以更直观理解（蓝色矩形代表执行阶段，橙色矩形代表共识阶段）：

#### 交错执行模式
在交错执行架构中，执行与共识的总时间预算等于区块间隔，且共识过程占据了绝大部分区块时间。

![asynchronous execution interleaved](/images/docs/asynchronous_execution_interleaved.png)
*交错执行*


#### 异步执行模式
在异步执行架构中，共识过程占据完整的区块时间——执行过程同样享有完整的区块时间，因为二者在独立的流水线中并行推进：

![asynchronous execution async](/images/docs/asynchronous_execution_async.png)
*异步执行*

#### 架构对比
将两种模式并置对比，可以清晰看到异步执行架构的优势：执行预算得以大幅扩展，从而充分利用完整的区块时间：

![asynchronous execution interleaved vs async](/images/docs/asynchronous_execution_interleaved_vs_async.png)
*上图：交错执行模式；下图：异步执行模式。*

### 确定的排序意味着状态确定性
尽管执行环节滞后于共识，但一旦交易排序被确定，世界的真实状态也就随之确定。执行过程只是揭示这一既定事实，而真相早已在共识达成时确立。

需要特别说明的是，在Monad中（与以太坊类似），区块中包含的交易完全允许"执行失败"——只要其直观预期结果未达成即属此类情况。（例如：某个区块可能包含这样一笔交易——Bob试图向Alice转账10个代币，但其账户余额仅有1个代币。此时转账会"失败"，但该交易本身仍然有效。）

所有交易的结果（包括执行失败）都具有确定性。


![asynchronous execution transaction order](/images/docs/asynchronous_execution_transaction_ordering.png)
*交易确定性示例（含交易失败场景）*


### 技术细节详解

#### 延迟默克尔根

如前所述，Monad 的区块提案不包含状态树的默克尔根，因为该值的生成需要先完成交易执行。

理论上所有节点都应保持同步状态，因为它们执行相同的工作流。但为确保万无一失，系统采取了预防措施：每个提案会同时包含前 `D1` 个区块的默克尔根（`D` 为系统参数，测试网当前设为 `3`），使节点能及时检测状态分歧。

延迟默克尔根的有效性构成区块有效性要件之一，若领导者提议的区块包含错误的延迟默克尔根，该区块将被直接拒绝。

这种延迟默克尔根机制带来两大关键特性：

基于这种延迟默克尔根机制，产生以下重要影响：

1. 当网络通过2/3多数投票对区块 `N` 达成共识时（通常发生在接收到包含区块 `N` 的QC级联认证的区块 `N+2` 时），意味着网络已正式确认：区块 `N-D` 的官方执行结果就是由默克尔根 `M` 锚定的确定状态。此时，轻客户端即可向全节点查询区块 `N-D` 上特定状态变量的默克尔证明。
2. 任何在区块 `N-D` 执行出错的节点，从区块`N` 开始将脱离共识状态。系统将自动触发该节点回滚至区块 `N-D-1` 的终态，随后重新执行区块 `N-D` 内的交易（预期将生成匹配的默克尔根），并继续按序重放后续区块 `N-D+1`、`N-D+2` 等的交易。

以太坊通过严格耦合共识与执行来实现状态机复制：节点达成共识后，我们可知超多数节点同时对交易排序及其产生的状态达成一致。然而这种严格性代价巨大——交错执行模式严重限制了执行吞吐量。异步执行在突破该限制的同时实现了状态机复制，而延迟默克尔根机制则提供了额外的安全防护。

![asynchronous execution delay state root](/images/docs/asynchronous_execution_state_root_delay.png)
*延迟默克尔根*

#### 储备余额机制
由于共识机制只能基于延迟K个区块的全局状态视图来运行，因此需要对共识和执行规则进行适当调整，以确保共识过程能够安全地构建仅包含那些gas费用可被支付的交易的区块。

为此，Monad引入了[储备余额规则](https://docs.monad.xyz/developer-essentials/reserve-balance)。该规则在共识阶段对交易打包施加轻度限制，并在执行阶段设定某些会导致交易回滚的条件。

#### 预执行机制
在MonadBFT中，节点在时隙 `N` 接收到被提议的区块 `N`，但该区块要到时隙 `N+2` 才会被最终确认。在此期间，节点仍可在本地预执行该提议区块（尽管无法保证该区块后续会进入"已投票"或"已最终确认"状态）。这一机制带来若干优势：

- 若提议区块最终被确认，验证节点因已提前完成执行工作，可立即将其默克尔根指针更新为执行结果
- 可通过 `eth_call` 或 `eth_estimateGas` 基于可能更新的预执行状态来模拟交易

#### 新充值账户的交易
由于共识进度略微领先于执行，此前余额为零的新充值账户，必须等待向其转账的交易达到`已验证`状态后，才能发送交易。

实践中这意味着：如果您从账户A向余额为零的账户B转账，需要等待看到交易回执（表明该区块已达`最终确认`状态）后，再额外等待约1.2秒。

另一种方案是：根据账户 `B` 预期交易的性质，可以编写一个可由 `A` 调用的智能合约，将资金转账操作与 `B` 要执行的操作合并处理，从而实现资金到位与使用的无缝衔接。

### 区块状态
关于区块在生命周期中经历的各状态概览，请参阅[区块状态](https://docs.monad.xyz/monad-arch/consensus/block-states)说明。
