# 高级主题

## 事件何时发布?

执行事件大致是在执行守护进程内部"实时发生"时记录的:您大约在执行守护进程开始处理新区块的同时看到 `BLOCK_START` 事件,随后大约 1 毫秒后看到第一个交易的开始(`TXN_HEADER_START` 事件)。大多数与交易相关的事件在它们描述的交易完成后不到一微秒就被记录。

典型交易的执行将发出几十个事件,但大型交易可能发出数百个事件。`TXN_EVM_OUTPUT` 事件——在交易完成后立即记录——提供了有关该交易将跟随多少更多事件的汇总统计(多少日志、多少调用帧等),以便可以预分配内存来存储后续事件数据。例如在 Rust 中,这里经常调用 [`Vec::reserve`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve)。像 `TXN_EVM_OUTPUT` 这样的事件在文档中被称为"头部事件":它是一个内容描述某些汇总信息和将在稍后记录更多详细信息的后续相关事件数量的事件。

所有这些事件都在交易"提交"到当前正在执行的区块后立即记录。这发生在区块完成执行之前,不应与共识算法中不相关的"承诺"概念混淆。尽管执行守护进程内部有复杂的推测执行优化,但交易的记录发生在特定交易上的所有工作完成时。这被称为"交易提交"时间。

这与您在例如 Geth 实时事件 WebSocket 协议(我们的 RPC 服务器也[支持](/reference/websockets))中看到的逐区块样式更新不同。在您看到交易事件时,区块的某些属性(其哈希、其状态根等)尚不知道,因为区块的其余部分仍在执行。如果您想要逐区块更新,Rust SDK 包含[一些实用程序](/execution-events/rust-api#block-level-utilities),它们将事件聚合回完整的面向区块的更新。

需要注意的一件事:尽管交易总是按索引顺序提交到区块,但它们可能会无序记录。也就是说,您必须假设构成交易 2 和 3 的执行事件集可以以任何顺序"混合在一起"。这是因为事件记录代码路径中的优化。

但是,*对于特定交易*(例如,交易 3),与该交易相关的事件总是以相同的顺序记录:首先是所有日志,然后是所有调用帧,然后是所有状态访问记录。每个都以*索引顺序*记录,即日志 2 总是在日志 3 之前记录。

考虑以下图表:

```text
╔═Events═════════════════════════════╗
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_EVM_OUTPUT   │  ║
  ║ │ transaction: 1                │  ║
  ║ │ log count:   2                │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_LOG          │  ║
  ║ │ transaction: 1                │  ║
  ║ │ log index:   0                │  ║
  ║ │ <log details>                 │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_EVM_OUTPUT   │  ║
  ║ │ transaction: 0                │  ║
  ║ │ log count:   3                │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_LOG          │  ║
  ║ │ transaction: 0                │  ║
  ║ │ log index:   0                │  ║
  ║ │ <log details>                 │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_LOG          │  ║
  ║ │ transaction: 0                │  ║
  ║ │ log index:   1                │  ║
  ║ │ <log details>                 │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_LOG          │  ║
  ║ │ transaction: 1                │  ║
  ║ │ log index:   1                │  ║
  ║ │ <log details>                 │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ║ ┌───────────────────────────────┐  ║
  ║ │ event type:  TXN_LOG          │  ║
  ║ │ transaction: 0                │  ║
  ║ │ log index:   2                │  ║
  ║ │ <log details>                 │  ║
  ║ └───────────────────────────────┘  ║
  ║                                    ║
  ╚════════════════════════════════════╝
```

这里需要注意几点:

- 与文档中的大多数图表不同,事件以简化的"合并"形式显示;在真实事件中,其中一些信息存储在事件描述符中,一些存储在事件有效载荷中,但它们被组合在一起以使图表更简单
- 它显示了两个交易,交易索引为 0 和 1。尽管交易 0 在 EVM 中首先完成,但其 `TXN_EVM_OUTPUT` 事件在交易 1 的 `TXN_EVM_OUTPUT` *之后*记录
- 来自交易的事件交错出现:有时下一个与交易 0 相关,有时与交易 1 相关,它们之间没有有意义的顺序
- 尽管交易相对于彼此是无序的,但与特定交易关联的所有事件总是以相对顺序排列,即特定交易的日志索引将始终以 `log_index` 顺序看到,如上所述

如果您想象交易的所有事件都由不同的线程记录,这很容易理解。对于特定交易,其线程总是按顺序记录该交易的事件,但"交易线程"本身相互竞争,以非确定性顺序记录。

这与实际发生的情况类似,只是交易记录在[纤程](https://en.wikipedia.org/wiki/Fiber_(computer_science))上而不是完整的线程上。

## 序列号和生命周期检测算法

所有事件描述符都标记有从 1 开始的递增序列号。序列号是 64 位无符号整数,除非执行守护进程重新启动,否则不会重复。零不是有效的序列号。

还要注意,序列号对描述符数组大小取模等于*下一个*事件描述符将位于的数组索引。下面用一个描述符数组大小为 64 的具体示例显示了这一点。请注意,数组中的最后一个有效索引是 63,然后访问回绕到索引 0 处数组的开头。

```text
◇
                                                         │
  ╔═...═════════════════════════Event descriptor array═══╬═══════════════════...═╗
  ║                                                      │                       ║
  ║     ┌─Event────────┐┌─Event────────┐┌─Event────────┐ │ ┌─Event─────────┐     ║
  ║     │              ││              ││              │ │ │               │     ║
  ║     │ seqnum = 318 ││ seqnum = 319 ││ seqnum = 320 │ │ │ seqnum = 256  │     ║
  ║     │              ││              ││              │ │ │               │     ║
  ║     └──────────────┘└──▲───────────┘└──────────────┘ │ └───────────────┘     ║
  ║            61          │   62              63        │         0             ║
  ╚═...════════════════════╬═════════════════════════════╬═══════════════════...═╝
                           │                             │
                           ■                             ◇
                           Next event                    Ring buffer
                                                         wrap-around to
      ┌──────────────────────────────┐                   zero is here
      │last read sequence number     │
      │(last_seqno) is initially 318 │
      └──────────────────────────────┘
```

在此示例中:

- 我们跟踪"最后看到的序列号"(`last_seqno`),其初始值为 `318`;作为"最后"序列号意味着我们已经完成了读取具有此序列号的事件,它位于数组索引 `61`
- `318 % 64` 是 `62`,因此如果已生成,我们将在该索引处找到潜在的下一个事件
- 观察到索引 `62` 处项目的序列号是 `319`,这是最后看到的序列号加 1(`319 == 318 + 1`)。这意味着事件 `319` 已被生成,可以从该插槽安全地读取其数据
- 当我们准备前进到下一个事件时,最后看到的序列号将增加到 `319`。如前所述,我们可以在 `319 % 64 == 63` 处找到*下一个*事件(如果已生成)。此索引处的事件具有序列号 `320`,这再次是最后看到的序列号 + 1,因此该事件也有效
- 第二次前进时,我们将最后看到的序列号增加到 `320`。这一次,索引 `320 % 64 == 0` 处的事件*不是* `321`,而是一个较小的数字 `256`。这意味着下一个事件尚未写入,我们在同一插槽中看到了一个较旧的事件。我们已经看到了所有当前可用的事件,需要在稍后写入新事件后再次检查
- 或者,我们可能看到了一个更大的序列号,比如 `384`(`320 + 64`)。这意味着我们消费事件太慢,以至于范围 `[321, 384)` 中的 63 个事件在此期间被生成。这些事件随后被覆盖,现在已丢失。它们可以使用事件环 API 外部的服务重放,但在事件环 API *本身内*无法恢复它们

## 事件有效载荷的生命周期,零拷贝 vs. memcpy API

由于描述符覆盖行为,事件描述符可能在读取器仍在检查其数据时被执行守护进程覆盖。为了处理这个问题,读取器 API 会制作事件描述符的副本。如果它检测到事件描述符在复制操作期间发生了变化,它会报告一个间隙。复制事件描述符很快,因为它的大小只有一个缓存行。

事件有效载荷的情况并非如此,它可能非常大。这意味着事件有效载荷的 `memcpy(3)` 可能很昂贵,直接从有效载荷缓冲区的共享内存段读取有效载荷字节会更有利:一个"零拷贝" API。这使用户面临事件有效载荷在仍在使用时可能被覆盖的可能性,因此提供了两种解决方案:

1. 简单的检测机制允许随时检测有效载荷覆盖:写入器跟踪仍然有效的最小有效载荷偏移值(*在*应用模运算之前)。如果事件描述符中的偏移值小于此值,则读取事件有效载荷不再安全
2. 还提供了 `memcpy` 样式的有效载荷 API。它以以下方式使用上述检测机制:首先,将有效载荷复制到用户提供的缓冲区。在返回之前,它检查副本完成后生命周期是否仍然有效。如果是,则在复制期间没有发生覆盖,因此副本必须有效。否则,副本无效

首选零拷贝 API 的原因是它们做的工作更少。首选 memcpy API 的原因是,如果您稍后发现事件有效载荷在您使用它时被覆盖而损坏,那么"撤消"您所做的工作并不总是容易的(或可能的)。在这种情况下,最合乎逻辑的做法是首先将数据复制到稳定位置,如果副本无效,则永远不要开始操作。

零拷贝 API 的示例用户是 `eventwatch` 示例 C 程序,它可以将事件转换为发送到 `stdout` 的打印字符串。使用原始有效载荷内存执行格式化事件有效载荷的十六进制转储的昂贵工作。如果在字符串格式化期间发生覆盖,十六进制转储输出缓冲区将是错误的,但这没关系:它不会发送到 `stdout` 直到最后。格式化完成后,`eventwatch` 检查有效载荷是否已过期,如果是,则将错误写入 `stderr` 而不是将格式化的缓冲区写入 `stdout`。

您是否应该复制取决于读取器的特性,即它能多容易地处理"中止"处理。

## 事件环文件的位置

出于性能原因,我们更倾向于在 [hugetlbfs](https://www.kernel.org/doc/html/v4.18/admin-guide/mm/hugetlbpage.html#hugetlbpage) 内存文件系统上创建事件环文件。在此类文件系统上创建的文件将由物理连续的大页面支持,这在内部基准测试中将性能提高了约 15%。

但这可能会很麻烦:程序要求文件放置在*特定类型*的文件系统上是不寻常的,并且这个要求增加了一些开销。在实践中,这意味着系统管理员在设置 Monad 节点时必须执行额外的配置步骤,以及 SDK 用户必须学习一些额外的概念。

问题是:

1. 必须在主机上某处挂载 hugetlbfs 文件系统;通常默认情况下(例如,在 Ubuntu 默认安装上)不会存在 hugetlbfs 文件系统
2. 配置 hugetlbfs 文件系统的人必须确保需要打开事件环文件的任何用户都具有适当的权限
3. 必须将事件环文件的路径(它将在该文件系统上的某处)传递给需要打开它的所有程序;由于我们不知道管理员将在哪里挂载文件系统,因此我们无法在文档或源代码中轻松地硬编码其位置

为了尽可能简化开发人员体验,我们遵循三个约定。每个约定都添加了更多"便利的默认行为",以便对于大多数用户来说一切都能"正常工作",但您可以自由忽略任何约定并以自己的方式做事。

**hugetlbfs 不是必需的**

事件环库不需要 hugetlbfs 文件系统:它可以与*任何*类型的常规文件一起工作。映射事件环共享内存段的 C 函数—— `monad_event_ring_mmap` ——只接受一个文件描述符,并不知道或不关心此描述符来自哪里。对它的唯一约束是 `mmap(2)` 系统调用本身施加的约束。

这些约定是关于为如何设置挂载点添加合理的默认值,以及用于在该位置查找事件环文件的辅助函数。您应该尝试使用它们,因为它们提供了性能优势,但您可以自由地以任何您希望的方式提供文件描述符,它将与 `monad_event_ring_mmap` 一起工作。

### 约定 1:节点设置指南中的 libhugetlbfs

设置本地 Monad 节点以支持执行事件的[官方指南](https://validator-docs.vercel.app/docs/full_node/events-and-websockets)推荐使用 `libhugetlbfs`。

`libhugetlbfs` 既是一个 C 库,也是一套使用该库的管理工具,遵循特定的配置约定。其想法是为 hugetlbfs 文件系统的挂载点和权限管理方式标准化一些规则。基本思想有三个部分:

1. 每个用户(或组,如果您想这样做的话)都有自己单独挂载的 hugetlbfs 文件系统。挂载点位于 `/var/lib/hugetlbfs/user/<user-name>` 下的明确定义的位置1
2. `hugeadm`,一个系统管理员运行的程序,是用于列出 hugetlbfs 挂载、创建新挂载等任务的配置前端
3. C 库 `libhugetlbfs` 帮助客户端程序"查找"当前用户有权访问的 hugetlbfs 挂载

Monad 节点的设置指南告诉用户安装 `libhugetlbfs` 命令行工具并为 `monad` 用户设置"用户挂载"。该指南还建议授予所有用户进入此目录的访问权限,以便作为非 `monad` 用户运行的数据消费应用程序可以打开文件。

### 约定 2:"默认"事件环目录

事件环库引入了"默认事件环目录"的概念。这是应该创建事件环文件的默认目录,因此读取器应用程序应该在其中查找它们。这个默认值可以来自两个地方之一:

1. 您可以手动提供它,或者
2. 如果您不提供它,库将使用约定的位置

约定的位置是一个名为 `event-rings` 的子目录,直接在 `libhugeltbfs` 返回的任何 hugetlbfs 挂载点下创建2,即:

```text
<libhugeltbfs-computed-mount-point>/event-rings
```

如果您严格遵循设置指南,这应该是:

```text
/var/lib/hugetlbfs/user/monad/pagesize-2MB/event-rings
```

但是,根据系统的设置方式,`libhugetlbfs` 可能会返回不同的路径。例如,您可能会看到类似这样的内容:

```text
/dev/hugepages/event-rings
```

这是因为 `libhugeltbfs` 抓取 `/proc/mounts` 的内容并仅返回当前用户有[访问权限](https://man7.org/linux/man-pages/man2/access.2.html)的一个路径。如果用户可以访问多个 hugetlbfs 挂载怎么办?没有逻辑来优先选择一种路径而不是另一种,它只取决于它们在 `/proc/mounts` 文件中的相对顺序。

#### 手动提供默认事件环目录

您可能希望使用这种"从默认目录打开"的配置习语,同时绕过 libhugetlbfs。这样做的两个原因是:

1. 如果您根本不希望事件环文件存在于 hugetlbfs 文件系统上;这通常是当您想要创建一个大于 hugetlbfs 挂载点(或系统底层大页面池)允许的事件环文件时
2. 如果您不想将 libhugetlbfs 用作项目的库依赖项,在这种情况下,您将希望将 CMake `MONAD_EVENT_USE_LIBHUGETLBFS` 选项设置为 `OFF`

### 约定 3:事件环文件名解析

"默认目录"概念用于最终约定,这是一个"便利" API 调用,用于将事件环文件的用户输入转换为程序将尝试打开该文件的路径。

它允许用户指定诸如 `xyz` 之类的文件名,并将其转换为如下完整(且难看的)路径:

```text
/var/lib/hugetlbfs/user/monad/pagesize-2MB/event-rings/xyz
```

同时仍然允许用户能够指定*任何*文件,包括不在默认目录中的文件(如果他们愿意)。

以下是 C 函数 `monad_event_ring_resolve_file` 和 Rust 函数 `EventRingPath::resolve` 如何解析事件环文件输入:

- 如果提供了"纯"文件名(即,没有 `/` 字符的文件名),则相对于提供的 `default_path` 目录解析
- 否则(即,如果文件包含任何 `/` 字符),则相对于当前工作目录解析;如果 `/` 是第一个字符,则将其解析为绝对路径

这类似于 UNIX shell 解析命令名的方式。没有路径字符的"纯"名称相对于 `$PATH` 环境变量中的条目解析(即,它搜索默认命令目录)。路径分隔符字符的存在导致输入被视为相对于当前目录的特定路径,从而禁用此"搜索"。这个熟悉的原则在这里适用。

此外:

- 在 C 中,您通常将哨兵值 `MONAD_EVENT_DEFAULT_HUGETLBFS`(它只是 `nullptr` 的别名)作为 `default_path` 参数传递;这会导致 `libhugetlbfs` 弄清楚默认 hugetlbfs 根路径应该是什么3;在 Rust 中,这只是 `EventRingPath::resolve`
- 您可以提供自己的 `default_path` 值,它可以位于任何文件系统上的任何路径上;如果您不想将 `libhugetlbfs` 作为依赖项,则这是必需的;在 Rust 中,这是 `EventRingPath::resolve_with_default_path`

**解析仅关于*生成*路径名**

解析不会尝试打开文件:它只是标准化如何从两个输入构建路径字符串的约定。也就是说,它不会检查计算的文件路径是否存在。

请记住,事件环库本身只关心文件描述符,其 API 都不会(即使是"辅助" API)尝试 [open(2)](https://man7.org/linux/man-pages/man2/open.2.html) 文件。它们只是提供程序可以选择的"合理默认"定位文件的方法。如果您的主机需要以不同方式设置文件系统挂载,您可以自由地这样做。

#### 示例

下表显示了 C 函数 `monad_event_ring_resolve_file` 的行为方式。`<cwd>` 是进程的当前工作目录,`<htlbfs>` 是 `libhugetlbfs` 返回的挂载点。

| `default_path` 值 | `input` 值 | resolve file 返回... | 注释
| `MONAD_EVENT_DEFAULT_HUGETLBFS` | `"xyz"` | `"<htlbfs>/event-rings/xyz"` |  
| `MONAD_EVENT_DEFAULT_HUGETLBFS` | `"a/b/c"` | `"<cwd>/a/b/c"` | `default_path` 仅影响"纯"文件名
| `MONAD_EVENT_DEFAULT_HUGETLBFS` | `"/d/e/f"` | `"/d/e/f"` | 绝对路径始终保持绝对
| `MONAD_EVENT_DEFAULT_HUGETLBFS` | `"monad-exec-events"` | `"<htlbfs>/event-rings/monad-exec-events"` | 执行守护进程使用的默认事件环文件名
| `"/tmp/my-event-ring-path"` | `"xyz"` | `"/tmp/my-event-ring-path/xyz"` | 如果不存在,将创建中间目录
| `"/tmp/my-event-ring-path"` | `"a/b/c"` | `"<cwd>/a/b/c"` |  
| `"/tmp/my-event-ring-path"` | `"/d/e/f"` | `"/d/e/f"` |  

在 Rust 中,`EventRingPath::resolve` 的行为类似于 `MONAD_EVENT_DEFAULT_HUGETLBFS` 行,而 `EventRingPath::resolve_with_default_path` 接受显式的 `basepath` 参数并且行为类似于底部三行。

## 脚注

1. 其他配置方案也是可能的,请参阅 [`man hugeadm`](https://linux.die.net/man/8/hugeadm) ↩
2. 确切的路径可能取决于用户,由函数 `hugetlbfs_find_path_for_size` 确定 ↩
3. 实际使用的函数是事件环库的实用函数 `monad_event_open_hugetlbfs_dir_fd`,它添加 `event-rings` 子目录路径组件,并在它不存在时创建它 ↩
